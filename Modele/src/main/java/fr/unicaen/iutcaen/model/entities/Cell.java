package fr.unicaen.iutcaen.model.entities;

import fr.unicaen.iutcaen.config.Config;
import fr.unicaen.iutcaen.model.Point;
import fr.unicaen.iutcaen.model.factories.IdDistributor;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.paint.Color;
import javafx.util.Duration;

import java.util.ArrayList;


/**
 * A Cell represents a circle in game <br>
 * It can eat pellets and other cells <br>
 */
public class Cell extends Entity{

    /**
     * whether the cell can unsplit or no
     */
    private boolean unSplit = false;

    /**
     * the list of all cells from the same cellPack
     */
    private ObservableList<Cell> neighbor = FXCollections.observableArrayList();

    /**
     * A Cell represents a circle in game <br>
     * It can eat pellets and other cells <br>
     * @param id The Id of the Cell. Most of the time it will be generated by the IdDistributor
     * @param position The position of the Cell on the map
     * @param mass The mass the cell contains
     * @param color the color of the cell
     */
    public Cell(int id, Point position, double mass, Color color) {
        super(id, position, mass, color);
        unSplitTimer.setCycleCount((int) (mass/Config.SPLIT_TIME_COEF_MASS + Config.BASE_SPLIT_TIME));
        unSplitTimer.setOnFinished(actionEvent -> {
            this.unSplit = true;
        });

    }

    private int timeAlive = 0;


    private double burstSpeed = 1;

    public void setBurstSpeed(double speedFactor) {
        this.burstSpeed = speedFactor;
    }

    /**
     * set the unsplit value to the given value
     * @param unsplit whether the cell can unsplit or not
     */
    public void setUnsplit(boolean unsplit){
        unSplit = unsplit;
    }

    /**
     * the timeline that is used as timer to know when the cell can unsplit
     */
    private Timeline unSplitTimer = new Timeline(new KeyFrame(Duration.millis(33), actionEvent -> {
        timeAlive++;
    }));

    /**
     * Checks if the cell touches another entity
     * @param e The entity that may touch the cell
     * @return true if the entity touches the cell or false otherwise
     */
    public boolean colide(Entity e){
        return this.position.distance(e.position) < (this.getSize() + e.getSize());
    }

    /**
     * Checks if the entity given is inside the Cell instance <br>
     * An entity is considered inside when its center is inside the cell circle <br>
     * @param e the entity we check if it's inside the cell
     * @return true id the entity is inside false otherwise
     */
    public boolean isInside(Entity e){
        return this.position.distance(e.position) < this.getSize();
    }

    /**
     * Calculates the cell speed in function of Config constants and of the cell's mass
     * @return A double that represents the speed of the cell
     */
    public double getSpeed(){
        return Config.MIN_SPEED + (Config.BASE_SPEED / Math.sqrt(this.getMass()));
    }

    /**
     * Checks if the Cell is big enough to eat another cell
     * @param cell the cell we want to compare to the instance
     * @return true if the instance is big enough to eat the given cell
     */
    public boolean canEat(Cell cell){
        return this.getMass() >= (cell.getMass() * Config.SIZE_RATIO_TO_EAT);
    }

    /**
     * Moves the cell towards a given position <br>
     * Resolving collisions
     * @param direction A point that defines the position desired
     */
    public void move(Point direction) {
        Point vecteurD = calculateDirectionVector(direction);
        vecteurD = scaleVectorIfNecessary(vecteurD);

        movePosition(vecteurD);
        handleCollisionsWithNeighbors();
        //handleChildCellRecomposition();
    }

    /**
     * Used for {@link #move(Point)} <br>
     * @param direction The position we want to go to
     * @return A vector going from the cell towards the cursors
     */
    private Point calculateDirectionVector(Point direction) {
        return new Point(direction.getX() - position.getX(), direction.getY() - position.getY());
    }

    /**
     * Used for {@link #move(Point)} <br>
     * Caps the vector to a maximum
     * So the distance of the mouse doesn't influence the cell speed after a certain distance
     * @param vecteurD The vector that needs to be caped
     * @return A reduced version of the vector if needed
     */
    private Point scaleVectorIfNecessary(Point vecteurD) {
        if (Math.abs(vecteurD.getX()) > Config.MAX_LENGTH_SPEED) {
            double ratio = Math.abs(vecteurD.getX()) / Config.MAX_LENGTH_SPEED;
            vecteurD.setX(vecteurD.getX() / ratio);
            vecteurD.setY(vecteurD.getY() / ratio);
        }
        if (Math.abs(vecteurD.getY()) > Config.MAX_LENGTH_SPEED) {
            double ratio = Math.abs(vecteurD.getY()) / Config.MAX_LENGTH_SPEED;
            vecteurD.setX(vecteurD.getX() / ratio);
            vecteurD.setY(vecteurD.getY() / ratio);
        }
        return vecteurD;
    }

    /**
     * Used for {@link #move(Point)} <br>
     * Changes the position of the cell towards the direction given
     * Depends on the cell's speed and on the Config SPEED_COEF
     * @param vecteurD the vector that represents the direction desired
     */
    private void movePosition(Point vecteurD) {
        Point newPos = position.add(vecteurD.multiply((getSpeed()  * burstSpeed)/ Config.SPEED_COEF));
        burstSpeed *= 0.92;
        if (burstSpeed < 1.01){
            burstSpeed = 1;
        }

        position.setX(newPos.getX());
        position.setY(newPos.getY());
    }

    /**
     * Adjust the position if the cell collides a cell from the same player <br>
     * uses {@link #resolveCollision(Cell)}
     */
    private void handleCollisionsWithNeighbors() {
        if (timeAlive > getSize() * 2 / (Config.BURST_SPEED) + 5){

            for (int i = 0; i < neighbor.size(); i++) {
                Cell cell = neighbor.get(i);
                if (cell.unSplit && cell != this) {
                    if (this.isInside(cell)){
                        reCompose(cell);
                    }
                }else {
                    if (cell != this && colide(cell)) {
                        resolveCollision(cell);
                    }
                }
            }
        }
    }

    /**
     * Sets the position of the cell if it collides the given cell <br>
     * @see #handleCollisionsWithNeighbors()
     * @param cell The cell it may collide with
     */
    private void resolveCollision(Cell cell) {
        double gap = position.distance(cell.position);
        Point vec = new Point(position.getX() - cell.position.getX(), position.getY() - cell.position.getY());

        double distance = vec.length();
        if (distance != 0) {
            vec = vec.multiply(1.0 / distance);

            double sizeRatio = cell.getSize() / (this.getSize() + cell.getSize());
            double moveDistance = -(gap - (this.getSize() + cell.getSize()));

            Point moveThis = vec.multiply(sizeRatio * moveDistance);
            Point moveCell = vec.multiply((1 - sizeRatio) * moveDistance);

            position.setX(position.getX() + moveThis.getX());
            position.setY(position.getY() + moveThis.getY());

            cell.position.setX(cell.position.getX() - moveCell.getX());
            cell.position.setY(cell.position.getY() - moveCell.getY());
        }
    }

    /**
     * Adds to the property neighbor the given cell
     * A neighbor is a cell from the same cell pack
     * @param neighbor the cell added to the neighbor List
     */
    public void setNeighbor(ObservableList<Cell> neighbor){
        this.neighbor = neighbor;
    }

    /**
     * Tries to eat an entity
     * if the entity is too far away or if the cell isn't big enough the entity won't be eaten
     * @param entity the entity eaten
     * @return true if the entity is successfully eaten and false otherwise
     */
    public Boolean absorbEntity(Entity entity) {
    	Boolean absorbed = false;

    	if(this.isInside(entity)) {

	       if(entity instanceof Pellet) {
	    	   Pellet pellet = (Pellet) entity;
	    	   pellet.applyEffect(this);

	    	   absorbed = true; 
	       }

	    	else if (entity instanceof Cell) {
                   Cell cell = (Cell) entity;
	    		if(this.canEat(cell)) {
	    			this.mass.set(cell.mass.getValue()+mass.getValue());
	    			absorbed = true; 
	    		}
	    	}
    	}
    	
    	return absorbed; 
    }


    /**
     * Merges the cell with the given cell
     * @param cell the cell that is merged with the instance
     */
    public void reCompose(Cell cell){
        neighbor.remove(cell);
        this.setMass(this.getMass() + cell.getMass());
    }

    /**
     * Starts the unsplitting process
     */
    public void unSplit() {
        unSplitTimer.play();
    }

    /**
     * *** crickets noises ðŸ¦—ðŸ¦—ðŸ¦— ***
     */
    @Override
    public void update() {

    }

    /**
     * Splits the cell into two cells
     * The cell's mass is divided by two and another cell (of the same size) is returned
     * @return A new cell created by the split
     */
    public Cell split(){
        if (neighbor.size() <= 1){
            timeAlive = 0;
            this.unSplit = false;
            this.unSplit();
        }
        if (this.getMass() > Config.MASS_REQUIRED_TO_SPLIT){

            this.setMass(this.getMass()/2);
            Cell newCell = new Cell(IdDistributor.getInstance().getNextId(), new Point(position.getX(), position.getY()), this.getMass(), this.getColor());
            newCell.unSplit();
            newCell.setBurstSpeed(Config.BURST_SPEED);
            return newCell;
        }
        return null;
    }

    public String toString() {
        return String.format("ID : %d, unsplit : %b", id, unSplit);
    }

    /**
     * Calculates the size of the cell (Radius)
     * Depends on the SIZE_RATIO_CELL
     * @return the size of the cell
     */
    public double getSize(){
        return Config.SIZE_RATIO_CELL *Math.sqrt(this.getMass());
    }
}
